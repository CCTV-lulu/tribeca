<!DOCTYPE html>
<html> 
<head> 
	<meta http-equiv="content-type" content="text/html; charset=UTF-8"/> 
	<title>Viewer Example</title> 
  <style>

    * {
      margin: 0;
      padding: 0;
    }

    body {
      overflow: hidden;
    }

  </style>
	<script src="https://maps.googleapis.com/maps/api/js?v=3.exp&sensor=false&libraries=places" type="text/javascript"></script> 
	<script src="third-party/dat.gui.min.js"></script>
	<script src="third-party/three.min.js"></script>
	<script src="third-party/GSVPano.js"></script>
	<script src="third-party/Hyperlapse.js"></script>
	<script src="third-party/underscore.js"></script>
	<script> 
	
		var start_point, end_point, lookat_point;

		var ma, directions_service, streetview_service;
		var cancelTimer = false;

		function getLocation() {
			navigator.geolocation.getCurrentPosition( getDestination, alert );
		}

		function getDestination(position) {
			start_point = new google.maps.LatLng( position.coords.latitude, position.coords.longitude );
	    map = new google.maps.Map(document.createElement("div"), {
	      mapTypeId: google.maps.MapTypeId.ROADMAP,
	      center: start_point,
	      zoom: 13
	    });

			var searchRequest = {
		    location: start_point,
		    //radius: 10000,
		    types: ['funeral_home', 'cemetery'],
		    rankBy: google.maps.places.RankBy.DISTANCE
		  };
			service = new google.maps.places.PlacesService(map);
			service.nearbySearch(searchRequest, getRoute);
			// service.textSearch(searchRequest, getRoute);
		}

		function getRoute( results, status ) {
			if (status == google.maps.places.PlacesServiceStatus.OK) {
		    end_point = results[0].geometry.location;
		    lookat_point = results[0].geometry.location;
				initMaps();
				initHyperlapse();
		  } else {
		  	alert("can't find route");
		  }
		}

		function initMaps() {
			function snapToRoad(point, callback) {
				var request = { origin: point, destination: point, travelMode: google.maps.TravelMode["DRIVING"] };
				directions_service.route(request, function(response, status) {
					if(status=="OK") callback(response.routes[0].overview_path[0]);
					else callback(null);
				});
			}

			var mapOpt = { 
				mapTypeId: google.maps.MapTypeId.ROADMAP,
				center: start_point,
				zoom: 15
			};

			var overlay = new google.maps.StreetViewCoverageLayer();
			overlay.setMap(map);

			directions_service = new google.maps.DirectionsService();

		}

		function initHyperlapse() {

			uniforms = {
					map: { type: "t", value: null },
					progress: { type: "f", value: null},
					lightness: { type: "f", value: 0},
					darkness: { type: "f", value: 0}
			};

			var material = material = new THREE.ShaderMaterial( {

					uniforms: uniforms,
					vertexShader: document.getElementById( 'vertexShader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentShader' ).textContent

				} );

			/* Hyperlapse */

			var pano = document.getElementById('pano');
			var is_moving = false;
			var px, py;
			var onPointerDownPointerX = 0, onPointerDownPointerY = 0;

			var hyperlapse = new Hyperlapse(pano, {
				lookat: lookat_point,
				fov: 100,
				millis: 50,
				width: window.innerWidth,
				height: window.innerHeight,
				zoom: 2,
				use_lookat: false,
				distance_between_points: 2,
				max_points: 5,
				material: material
			});
			

			hyperlapse.onError = function(e) {
				console.log( "ERROR: "+ e.message );
			};

			hyperlapse.onRouteComplete = function(e) {
				hyperlapse.load();
			};

			hyperlapse.onLoadComplete = function(e) {
          // hyperlapse.play();
			};

			hyperlapse.onFrame = function(e) {
				var progress = (e.position+1)/hyperlapse.length();
				material.uniforms.progress.value = progress;
				material.uniforms.lightness.value = progress;
			};

			pano.addEventListener( 'mousedown', function(e){

        /**
         * New Controls
         */

        initializeTimer();

        return;

				e.preventDefault();

				is_moving = true;

				onPointerDownPointerX = e.clientX;
				onPointerDownPointerY = e.clientY;

				px = hyperlapse.position.x;
				py = hyperlapse.position.y;

			}, false );

			pano.addEventListener( 'mousemove', function(e){

        /**
         * New Controls
         */

        return;

				e.preventDefault();
				var f = hyperlapse.fov() / 500;

        if ( is_moving ) {
					var dx = ( onPointerDownPointerX - e.clientX ) * f;
					var dy = ( e.clientY - onPointerDownPointerY ) * f;
					hyperlapse.position.x = px + dx; // reversed dragging direction (thanks @mrdoob!)
					hyperlapse.position.y = py + dy;

					o.position_x = hyperlapse.position.x;
					o.position_y = hyperlapse.position.y;
        }
			}, false );

			pano.addEventListener( 'mouseup', function(){

        /**
         * New Controls
         */

        cancelTimer = true;

        return;

				is_moving = false;
				// hyperlapse.position.x = px;
				// hyperlapse.position.y = py;
			}, false );

			/* Dat GUI */

			var gui = new dat.GUI();

			var o = {
				tilt:0, 
				position_x:0,
				position_y:0,
				screen_width: window.innerWidth,
				screen_height: window.innerHeight,
				lightness: 0,
				generate:function(){
					request = {
						origin: start_point, 
						destination: end_point, 
						travelMode: google.maps.DirectionsTravelMode.DRIVING
					};

					directions_service.route(request, function(response, status) {
						if (status == google.maps.DirectionsStatus.OK) {   
							hyperlapse.generate({route: response});
						} else {
							console.log(status);
						}
					})
				},
			};

			var parameters = gui.addFolder('parameters');

			var position_x_control = parameters.add(o, 'position_x', -360, 360).listen();
			position_x_control.onChange(function(value) {
				hyperlapse.position.x = value;
			});

			var position_y_control = parameters.add(o, 'position_y', -180, 180).listen();
			position_y_control.onChange(function(value) {
				hyperlapse.position.y = value;
			});

			var tilt_control = parameters.add(o, 'tilt', -Math.PI, Math.PI);
			tilt_control.onChange(function(value) {
				hyperlapse.tilt = value;
			});


			var lightness_control = parameters.add(o, 'lightness', 0, 1);
			lightness_control.onChange(function(value) {
				material.uniforms.lightness.value = value;
			});

			// parameters.open();
			
			var play_controls = gui.addFolder('play controls');
			play_controls.add(hyperlapse, 'play');
			play_controls.add(hyperlapse, 'pause');
			play_controls.add(hyperlapse, 'next');
			play_controls.add(hyperlapse, 'prev');
			play_controls.open();

      // gui.hide();
      gui.domElement.style.display = 'none';

			window.addEventListener('resize', function(){
				hyperlapse.setSize(window.innerWidth, window.innerHeight);
				o.screen_width = window.innerWidth;
				o.screen_height = window.innerHeight;
			}, false);

			document.addEventListener( 'keydown', onKeyDown, false );
			function onKeyDown ( event ) {

				switch( event.keyCode ) {
					case 190: /* > */
						hyperlapse.next();
						break;

					case 188: /* < */
						hyperlapse.prev();
						break;
				}

			};

			o.generate();

      function initializeTimer() {
        accelerate();
        cancelTimer = false;
      }

      function accelerate() {

        if (!hyperlapse) {
          return;
        }

        hyperlapse.next();

        if (!cancelTimer) {
          _.delay(requestAnimationFrame, getTimeout(accelAmount), accelerate);
        }
      }

      function getTimeout(accelAmount) {
        
      }

		}

		window.onload = function() {
			getLocation();
		}

	</script> 
</head> 
		<script id="vertexShader" type="x-shader/x-vertex">

			varying vec2 vUv;
			varying vec3 vNormal;

			void main()	{

				vUv = uv;
				vNormal = normal.xyz;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script id="fragmentShader" type="x-shader/x-fragment">

			varying vec2 vUv;
			varying vec3 vNormal;
			uniform sampler2D map;
			uniform float darkness;
			uniform float lightness;

			void main()	{

				vec3 tex = texture2D( map, vUv ).xyz;
				float grayscale = (tex.r+tex.g+tex.b)/3.0;

				float highlights = (grayscale-2.0/3.0);

				float light = max((vNormal.x-1.0+lightness)*(4.*lightness),0.);
				float dark = max((-vNormal.x-1.0+lightness)*(4.*lightness),0.);

				gl_FragColor = vec4(tex+light-dark, 1.0);

			}

		</script>
<body> 
	<div id="pano" style="position: absolute; left: 0; top: 0; right: 0; bottom: 0; z-index:-1;"></div>	
</body> 
</html>